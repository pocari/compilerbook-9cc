// vim:set ft=c:
int test_count;
int ok_count;
void *calloc();
int strcmp();

int printf();

// test_func.c
int foo_with_args_add(int a, int b);
int foo_with_args_add6(
    int a1,
    int a2,
    int a3,
    int a4,
    int a5,
    int a6
);
int foo_return2();
// TODO: 戻り値voidだがまだvoid実装してないので一旦int型で宣言しておく
int alloc_3num_ary_8_byte_cell(int **p);

int assert(int expected, int actual, char *code) {
  test_count = test_count + 1;
  if (expected == actual) {
    ok_count = ok_count + 1;
    printf("%s => %d\n", code, actual);
  } else {
    printf("%s => %d expected, but got %d\n", code, expected, actual);
  }
}
int f1_while() {
  int i;
  i = 0;
  while (i < 10)
    i = i + 1;
  return i;
}

int f2_while() {
  int i;
  int sum;
  i = 0;
  sum = 0;
  while (i < 10) {
    sum = sum + 3;
    i = i + 1;
  }
  return sum;
}
int f3_if() {
  int foo;
  foo = 1;
  if (foo == 1) {
    return 11;
  }
  return 12;
}

int f4_if() {
  int foo;
  foo = 2;
  if (foo == 1) {
    return 11;
  } else if (foo == 2) {
    return 12;
  } else {
    return 13;
  }
  return 14;
}

int f5_if() {
  int foo;
  foo = 3;
  if (foo == 1) {
    return 11;
  } else if (foo == 2) {
    return 12;
  } else {
    return 13;
  }
  return 14;
}

int f6_if() {
  int foo;
  foo = 0;
  if (foo == 1) {
    return 11;
  }
  return 12;
}

int f7_if() {
  int foo;
  foo = 0;
  if (foo == 1) {
    return 11;
  } else {
    return 13;
  }
  return 12;
}

int f8_if() {
  int foo;
  foo = 1;
  if (foo == 1) {
    return 11;
  } else {
    return 13;
  }
  return 12;
}

int f9_while_if() {
  int sum;
  int i;
  i = 0;
  sum = 0;
  while (i < 10) {
    sum = sum + 2;
    i = i + 1;
  }
  if (sum == 20) {
    return 4;
  } else {
    return 5;
  }
}

int f10_while_if() {
  int i;
  int sum;

  i = 0;
  sum = 0;
  while (i < 10) {
    sum = sum + 2;
    i = i + 1;
  }
  if (sum != 20) {
    return 4;
  } else {
    return 5;
  }
}

int f11_return() {
  int returnx; returnx = 11; return returnx;
}

int f12_for() {
  int sum;
  int i;
  sum = 0;
  for (i = 0; i < 10; i = i + 1) {
    sum = sum + i;
  }
  return sum;
}

int f13_for() {
  int sum;
  int i;
  sum = 0;
  i = 0;
  for (; i < 10; i = i + 1) {
    sum = sum + i;
  }
  return sum;
}

int f14_for() {
  int sum;
  int i;
  sum = 0;
  i = 0;
  for (; i < 10;) {
    sum = sum + i;
    i = i + 1;
  }
  return sum;
}

int f15_call_func() {
  int foo;
  int bar;
  foo = 1;
  bar = 2;
  return foo_with_args_add(foo + bar, 3 + 4);
}

int fact(int n) {
  if (n == 1) {
    return 1;
  } else {
    return fact(n - 1) * n;
  }
}

int fib(int n) {
  if (n == 1) {
    return 1;
  } else {
    if (n == 2) {
      return 1;
    } else {
      return fib(n - 1) + fib(n - 2);
    }
  }
}

int f16_for_while_if_func_arg(int a, int b) {
  int i;
  int j;
  int a;
  int b;
  for (i = 0; i < 10; i = i + 1) {
    a = a + 1;
  }
  j = 0;
  while (j < 10) {
    b = b + 1;
    j = j + 1;
  }
  if (a + b > 0) {
    return 1;
  } else {
    return 0;
  }
}

int f17_pointer() {
  int x;
  int *y;
  int **z;

  x = 12;
  y = &x;
  z = &y;

  **z = 23;

  return x;
}

int f18_ary() {
  int a[2];
  *a = 1;
  *(a + 1) = 2;
  int *p;
  p = a;
  return *p + *(p + 1);
}

int f19_ary() {
  int a[2];
  a[0] = 1;
  a[1] = 2;
  int *p;
  p = a;
  return *p + *(p + 1) + a[1 - 1] + a[0 + 1];
}

int f20_ary_helper() {
  return 2;
}

int f20_ary() {
  int a[2];
  a[0] = 1;
  a[1] = 2;
  int *p;
  p = a;
  return *p + *(p + 1) + 0[a] + (-1 + f20_ary_helper())[a];
}

int f21_ary() {
  int a[2][3];
  int *p;

  a[0][0] = 1;
  a[0][1] = 2;
  a[0][2] = 3;
  a[1][0] = 4;
  a[1][1] = 5;
  a[1][2] = 6;

  p = a + 1;

  return a[0][0] + a[0][1] + a[0][2] + *p + *(p + 1) + *(p + 2);
}

int f22_x;

int f23_x;
int f23_x_test(int n) {
  f23_x = n;
}

int f24_x[3];
int f24_helper() {
  f24_x[0] = 1;
  f24_x[1] = 2;
  f24_x[2] = 3;
  int *p;
  p = f24_x;
  return *p + *(p + 1) + *(p + 2);
}

int *f25_x;
int f25_helper() {
  int y;
  y = 12;
  f25_x = &y;
  return *f25_x;
}

int f26_char() {
  char x[3];
  x[0] = 1;
  x[1] = 2;
  char y;
  y = 4;
  return x[0] + y;
}

char f27_x[2];
int f27_helper() {
  f27_x[0] = 2;
  f27_x[1] = 3;
  return f27_x[0] + f27_x[1];
}

int f28_sub_char(char a, char b, char c) {
  return a - b - c;
}

int f29_helper() {
  return 3;
}

int f29_initialize_local_var() {
  int x = 10;
  int *y = &x;
  int z = f29_helper();
  int hoge[2] = {2, 3};
  int foo[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int boo[2] = {hoge[0], hoge[1]};
  return x + *y + z + 2 + hoge[0] + hoge[1]
  + foo[0][0]
  + foo[0][1]
  + foo[0][2]
  + foo[1][0]
  + foo[1][1]
  + foo[1][2]
  + boo[0]
  + boo[1];
}

int f30_struct_member() {
  struct {
    int m1;
    char m2;
    int m3[2];
    int *m4;
  } x;
  int y = 5;

  x.m1 = 1;
  x.m2 = 2;
  x.m3[0] = 3;
  x.m3[1] = 4;
  x.m4 = &y;

  return
    x.m1 +
    x.m2 +
    x.m3[0] +
    x.m3[1] +
    *x.m4
    ;
}

int f31_local_variable_alignment() {
  char x;
  int y;

  // テスト用に無理やりアドレスをint型にいれる
  long a = &x;
  long b = &y;

  /*
   * スタックは現状ローカル変数の宣言の逆順にスタックに確保されるため、char, int の順で宣言するとスタック上は下記のようになる
   * -----------> スタックの伸びる方向(アドレスが小さくなる方向)
   *
   *                 int y;
   *                  |
   *                  v
   * +----------------+
   * | 4byte          |
   * +----------------+
   * ^
   * |
   * rbp
   *
   * 次にcharを積むが、charのアラインメントは1byteなので、素直にint yの上に char xの領域を確保し、下記のようになる
   *
   *                 int y;   char x;
   *                  |       |
   *                  v       v
   * +----------------+-------+
   * | 4byte          | 1byte |
   * +----------------+-------+
   * ^
   * |
   * rbp
   *
   * なので、xのアドレスとyのアドレスは1byteだけ離れている
   */
  return b - a;
}

int f32_local_variable_alignment() {
  int x;
  char y;

  // テスト用に無理やりアドレスをint型にいれる
  long a = &x;
  long b = &y;

  /*
   * スタックは現状ローカル変数の宣言の逆順にスタックに確保されるため、int, char の順で宣言するとスタック上は下記のようになる
   * -----------> スタックの伸びる方向(アドレスが小さくなる方向)
   *
   *        char y;
   *         |
   *         v
   * +-------+
   * | 1byte |
   * +-------+
   * ^
   * |
   * rbp
   *
   * 次にintを積むが、intのアラインメントは4byteなので、charの直後には積めず、4byte境界になるように調整されるので、
   * rbpからみて2個目(1個目の4の倍数の領域にはchar yがいるため)の4の倍数=rbpからみて8byteの位置にint xの両利きを確保し下記のようになる
   *
   *        char y;                    int x;
   *         |                         |
   *         v                         v
   * +-------+--------+----------------+
   * | 1byte | 3byte  | 4byte          |
   * +-------+--------+----------------+
   *         |padding |<-- xの領域  -->|
   * ^
   * |
   * rbp
   *
   * なので、xのアドレスとyのアドレスは7byte(隙間の3byte + int xのサイズの4byte)だけ離れている
   */
  return b - a;
}

int f33_use_struct_tag() {
  struct tag1 {
    int x;
    int y;
  } o;

  struct tag2 {
    int m;
    int n;
  } p;

  struct tag1 tag1_var;
  struct tag2 tag2_var;

  o.x = 1;
  o.y = 2;
  p.m = 3;
  p.n = 4;
  tag1_var.x = 5;
  tag1_var.y = 6;
  tag2_var.m = 7;
  tag2_var.n = 8;

  return o.x + o.y + p.m + p.n + tag1_var.x + tag1_var.y + tag2_var.m + tag2_var.n;
}

int f34_arrow_operator() {
  struct tag {
    int x;
    int y;
  } m;

  struct tag *n = &m;

  m.x = 2;
  n->y = 3;

  return m.x + m.y + n->x + n->y;
}

int f35_typedef_stmt() {
  int x = 10;
  typedef int hoge;
  typedef int foo;
  hoge y = 20;
  foo z = 30;

  return x + y + z;
}

typedef struct hoge_hoge {
  int x;
  int y;
} hoge_hoge;

int f36_global_typedef() {
  hoge_hoge x;
  typedef hoge_hoge *pointer_of_hoge_hoge;

  pointer_of_hoge_hoge y = &x;
  y->x = 1;
  y->y = 2;

  return x.x + x.y;
}

int f37_fix_char_mov() {
  char x = -1;
  char y = 3;

  return x + y;

}

int f39_struct_included_long() {
  struct {
    char x;
    int y;
    long z;
  } s;

  return sizeof(s);
}

int f41_long_short_int_char_args(long a, short b, int c, char d) {
  return a + b + c + d;
}
int f42_use_all_argument_register_short(short a, short b, short c, short d, short e, short f) {
  return a + b + c + d + e + f;
}

int f42_use_all_argument_register_int(int a, int b, int c, int d, int e, int f) {
  return a + b + c + d + e + f;
}

int f42_use_all_argument_register_char(char a, char b, char c, char d, char e, char f) {
  return a + b + c + d + e + f;
}

int f43_nested_decl() {
  // x は intへのポインタの配列(要素は3)
  // => 4byte * 3 = 12byte
  int *x[3];

  // y は 「intの配列(要素は4)」へのポインタ
  // => ポインタなので8byte
  int (*y)[4];

  // z は 「intの配列(要素は5)」
  // => 4byte * 5 = 20 byte
  int z[5];

  int m[2][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8}
  };
  y = m;
  m[1][0] = 9;


  assert(24, sizeof(x), "sizeof(x)");
  assert(8, sizeof(y), "sizeof(y)");
  assert(20, sizeof(z), "sizeof(z)");


  assert(4, y[0][3], "y[0][3]");
  assert(9, y[1][0], "y[1][0]");
  assert(6, y[1][1], "y[1][1]");
}

// 宣言
int f44_hogehoge(int x, char y);

// 定義
int f44_hogehoge(int x, char y) {
  return x + y;
}

// voidのテストがよくわからないので voidの戻り値の関数内でvoid *ポインタを定義してエラーにならないことだけ確認
void f45_call_void_func() {
  void *x;
}

void f46_bool_test() {
  _Bool a = 0;
  _Bool b = 1;
  _Bool c = 2;

  assert(0, a, "a == 0");
  assert(1, b, "b == 1");
  assert(1, c, "c == 1");

  if (a) {
    assert(1, 2, "ここにはこないはず");
  } else {
    assert(1, 1, "a is false");
  }

  if (c) {
    assert(1, 1, "c is true");
  } else {
    assert(1, 2, "ここにはこないはず");
  }
}

void f47_long_long() {
  long long a = 10;
  long long *b = &a;

  assert(10, *b, "*b");
  assert(8, sizeof(a), "sizeof(a)");
}

typedef f48_global_typedef_01;
typedef char f48_global_typedef_02;
short typedef  f48_global_typedef_03;
int f48_global_var_04;
long int *f48_global_var_05;
f48_global_typedef_01 f48_global_var_06;

void f48_complex_decl() {
  int a;
  long b;
  long long c;
  long long int d;
  long int long e;
  int long long f;
  char g;
  void *h;
  short i;
  short int j;
  int short k;
  typedef typedef l;
  l m;
  long typedef n;
  n o;

  assert(4, sizeof(a), "sizeof(a)");
  assert(8, sizeof(b), "sizeof(b)");
  assert(8, sizeof(c), "sizeof(c)");
  assert(8, sizeof(d), "sizeof(d)");
  assert(8, sizeof(e), "sizeof(e)");
  assert(8, sizeof(f), "sizeof(f)");
  assert(1, sizeof(g), "sizeof(g)");
  assert(8, sizeof(h), "sizeof(h)");
  assert(2, sizeof(i), "sizeof(i)");
  assert(2, sizeof(j), "sizeof(j)");
  assert(2, sizeof(k), "sizeof(k)");
  assert(4, sizeof(m), "sizeof(m)");
  assert(8, sizeof(o), "sizeof(o)");
}

void f49_sizeof_type_argument() {
  typedef struct hoge {
    int x;
    long y;
  } hoge;

  assert(4, sizeof(int), "sizeof(int)");
  assert(8, sizeof(int *(*)[3]), "sizeof(int *(*y)[3])");
  assert(16, sizeof(hoge), "sizeof(hoge)");
}

void f50_large_number_literal() {
  long x = 2147483647; // 2 ^ 31 - 1
  long y = 2147483648; // 2 ^ 31

  assert(y, x + 1, "y == x + 1");
}

void f51_unary_test() {
  typedef struct hoge {
    int x;
  } hoge;

  hoge s;
  s.x = 12;

  int *y = &s.x;
  assert(12, *y, "*y");
}

void f52_cast_test() {
  // 16進リテラルがまだないのでコメントで補足
  long x = 0x123456789A;

  _Bool b = (_Bool)x;
  char c = (char)x;
  short s = (short)x;
  int i = (int)x;

  assert(0x01, b, "(_Bool)x");

  // 0x9A(符号付きcharで154でなく-102になる)
  // rubyでいうと "\x9A".unpack("C") でなく、 "\x9A".unpack("c")
  // 0x9Aが10011010と、8bit目が1なので符号付きのcharとしてはマイナスになるので、ここは10進数で比較
  assert(-102, c, "(char)x");
  assert(0x789A, s, "(short)x");
  assert(0x3456789A, i, "(int)x");
  assert(0, (_Bool)(char)256, "(_Bool)(char)256");
}

void f53_char_literal_test() {
  assert(97, 'a', "'a'");
  assert(110, 'n', "'n'");
  assert(10, '\n', "'\\n'");
  assert(9, '\t', "'\\t'");
  assert(39, '\'', "'\\''");
  assert(34, '\"', "'\\''");
  assert(34, '"', "'\\\"'");
  assert(92, '\\', "'\\\\'");
  assert(48, '0', "'0'");
  assert(0, '\0', "'\\0'");
}

void f54_enum_test() {
  // enum型の変数宣言trailing commaあり
  enum {
    X1,
    X2 = 5,
    X3,
  } x = X3;

  // enum型の変数宣言trailing commaなし
  enum {
    Y1,
    Y2 = 5,
    Y3
  } y = Y2;

  // タグつきenum変数
  enum enum_z {
    Z1,
    Z2,
    Z3,
  } z = Z2;

  // 既存のenumタグから変数宣言
  enum enum_z z2 = Z3;

  // typedef しながらenum定義
  typedef enum enum_hoge_tag {
    HOGE1 = 1,
    HOGE2 = 2,
    HOGE3
  } enum_hoge;

  // タグ名から変数宣言
  enum enum_hoge_tag hoge_var1 = HOGE2;
  // typedefされた型名から変数宣言
  enum_hoge hoge_var2 = HOGE3;

  // 既存のenumタグをtypedefで型定義
  typedef typedef enum enum_z typedef zzz;
  zzz z3 = Z1;

  assert(6, x, "x");
  assert(5, y, "y");
  assert(1, z, "z");
  assert(2, z2, "z2");
  assert(2, hoge_var1, "hoge_var1");
  assert(3, hoge_var2, "hoge_var2");
  assert(0, z3, "z3");
}

void f55_for_var_decl_test() {
  int i = 10;
  int sum = 0;
  for (int i = 0; i < 10; i = i + 1) {
    sum = sum + i;
  }
  assert(45, sum, "sum");
  // forの外側のiなので変わらないはず
  assert(10, i, "i");

}

void f56_coma_test() {
  assert(3, (1, 2, 3), "(1, 2, 3)");

  int j_sum = 0;
  int i_sum = 0;
  for (int i = 0, j = 0; i < 10; i = i + 1, j = j + 2) {
    // 0, 2, 4, 6, 8, 10, 12, 14, 16, 18
    i_sum = i_sum + i;
    j_sum = j_sum + j;
  }

  assert(45, i_sum, "i_sum");
  assert(90, j_sum, "j_sum");
}

void f57_multi_var_decl_test() {
  int i = 10, *j = &i, k[2] = {2, 3};

  assert(10, i, "i == 10");
  assert(10, *j, "*j == i");
  assert(&i, j, "j == &i");
  assert(2, k[0], "k[0]");
  assert(3, k[1], "k[1]");
}

void f58_inc_dec_test() {
  int i = 2;
  int x = ++i;

  assert(3, x, "x");
  assert(3, i, "i");

  int y = --i;
  assert(2, y, "y");
  assert(2, i, "i");

  int j = 3;
  int m = j++;
  assert(3, m, "m");
  assert(4, j, "j");

  int n = j--;
  assert(4, n, "n");
  assert(3, j, "j");

  int ary[3] = {2, 3, 4};
  int *p = ary;

  assert(2, *p++, "*p++");
  assert(3, *p++, "*p++");
  assert(4, *p++, "*p++");

  assert(4, *--p, "*--p");
  assert(3, *--p, "*--p");
  assert(2, *--p, "*--p");
}

void f59_assign_with_operator_test() {
  int i = 1;

  i += 2;
  assert(3, i, "i");

  i -= 4;
  assert(-1, i, "i");

  i *= -7;
  assert(7, i, "i");

  i /= 2;
  assert(3, i, "i");

  int a = 2;
  int b = 3;

  a += b += 4;

  assert(7, b, "b");
  assert(9, a, "a");


  int x[3] = {2, 3, 4};
  int *p = x;

  assert(2, *p, "*p");

  p += 1;
  assert(3, *p, "*p");

  p += 1;
  assert(4, *p, "*p");

  p -= 1;
  assert(3, *p, "*p");
}

void f60_hex_octal_number_test() {
  long x = 0x0;
  assert(0, x, "x");

  x = 0x1234;
  assert(4660, x, "x");

  x = 0xA;
  assert(10, x, "x");

  x = 0xa;
  assert(10, x, "x");

  x = 0xABCDEF;
  assert(11259375, x, "x");

  x = 0000000000;
  assert(0, x, "x");

  x = 010;
  assert(8, x, "x");

  x = 01234567;
  assert(342391, x, "x");

  x = 0b0;
  assert(0, x, "x");

  x = 0b1;
  assert(1, x, "x");

  x = 0b10;
  assert(2, x, "x");
}

void f61_not_operator_test() {
  int x = 10;
  assert(0, !x, "!x");
  assert(1, !!x, "!!x");
  assert(1, !0, "!0");
  assert(0, !1, "!1");
  assert(0, !(x == 10), "!(x == 10)");
  assert(1, !(x - 10), "!(x - 10)");
}

void f62_bit_not_operator_test() {
  assert(-1, ~0, "~0");
  assert(0, ~-1, "~-1");
}

void f63_bit_binary_op_test() {

  /*
    0b111
  & 0b110
  -------
    0b110

    0b010
  ^ 0b110
  -------
    0b100

    0b101
  | 0b100
  -------
    0b101 == 5
  */


  assert(5, 0b101 | 0b010 ^ 0b111 & 0b110, "0b101 | 0b010 ^ 0b111 & 0b110;");
}

void f64_logical_adn_or_test() {
  // || のチェック
  assert(1, 1 || 1 , "1 || 1");
  assert(1, 1 || 0 , "1 || 0");
  assert(1, 0 || 1 , "0 || 1");
  assert(0, 0 || 0 , "0 || 0");

  // && のチェック
  assert(1, 1 && 1 , "1 && 1");
  assert(0, 1 && 0 , "1 && 0");
  assert(0, 0 && 1 , "0 && 1");
  assert(0, 0 && 0 , "0 && 0");

  // 優先順位のチェック
  assert(1, 1 || 1 && 0, "1 || 1 && 0");
  assert(0, (1 || 1) && 0, "1 || 1 && 0");

  // 短絡評価の確認
  typedef struct hoge {
    int x;
  } hoge;
  hoge *p = 0;

  // 短絡評価されてなかったらヌルポでsegvするはず
  assert(1, 1 || p->x, "1 || p->x");
  assert(0, 0 && p->x, "0 && p->x");
}

void f65_helper(int a[]) {
  return a[3];
}

void f65_array_arg_as_pointer_test() {
  int ary[4] = {1, 2, 3, 4};

  assert(4, f65_helper(ary), "f65_helper(ary)");
}

void f66_fix_struct_decl_test() {
  // 構造体の型だけ定義する、というのが出来なかったのでそのテスト

  // 構造体の定義 + 変数の定義
  struct hoge {
    int x;
  } hoge_var;


  // 構造体の型定義のみ
  struct foo {
    int y;
  };

  // 定義済みの構造体のタグから変数定義
  struct foo foo_var;
  struct foo *foo_var_pointer = &foo_var;

  hoge_var.x = 42;

  foo_var_pointer->y = hoge_var.x;

  assert(42, foo_var.y, "foo_var.y");

  // enumも同様
  enum piyo {
    aaa = 2,
    bbb,
    ccc
  };

  enum piyo piyo_var;
  piyo_var = bbb;

  assert(3, piyo_var, "piyo_var");
}

void f67_improve_struct_decl_test() {
  // 不完全型で、まず定義
  struct hoge;

  // 不完全型の状態でポインタ定義
  struct hoge *p;

  // ここで完全型として再定義
  struct hoge {
    int x;
    int y;
  };

  // 構造体変数
  struct hoge hoge_var;

  p = &hoge_var;
  p->x = 12;
  p->y = 34;

  assert(12, hoge_var.x, "hoge_var.x");
  assert(34, hoge_var.y, "hoge_var.x");


  // 入れ子になった構造体のタグの確認
  struct LinkList {
    struct LinkList *next;
    int val;
  };

  struct LinkList *p = 0;
  for (int i = 0; i < 10; i++) {
    struct LinkList *tmp = calloc(1, sizeof(struct LinkList));
    tmp->next = p;
    tmp->val = i;
    p = tmp;
  }

  int sum = 0;
  for (struct LinkList *x = p; x; x = x->next) {
    sum += x->val;
  }
  assert(45, sum, "sum");


  // 謎の不完全無名構造体へのポインタの確認
  struct *piyo;
  assert(8, sizeof(piyo), "sizeof(piyo)");
}

void f68_break_test() {
  int i;
  for (i = 0; i < 10; i++) {
    if (i == 5) {
      break;
    }
  }
  assert(5, i, "i");

  i = 0;
  while (i < 10) {
    if (i == 7) {
      break;
    }
    i++;
  }
  assert(7, i, "i");
}

void f69_continue_test() {
  int sum = 0;
  for (int i = 0; i < 5; i++) {
    if (i == 2) {
      continue;
    }
    // 2だけ無視されて
    // 0 + 1 + 3 + 4 になる
    sum += i;
  }
  assert(8, sum, "sum");

  sum = 0;
  for (int i = 0; i < 5;) {
    if (i == 2) {
      i++;
      continue;
    }
    // 2だけ無視されて
    // 0 + 1 + 3 + 4 になる
    sum += i;
    i++;
  }
  assert(8, sum, "sum");

  int i = 0;
  sum = 0;
  while (i < 5) {
    if (i == 2) {
      i++;
      continue;
    }
    // 2だけ無視されて
    // 0 + 1 + 3 + 4 になる
    sum += i;
    i++;
  }
  assert(8, sum, "sum");
}

void f70_goto_test() {
  // 1 -> 2 -> 3 -> 4 -> endの順にジャンプする
  int i = 0;
  goto L1;

L4:
  assert(4, ++i, "++i");
  goto LEND;
L3:
  assert(3, ++i, "++i");
  goto L4;
L2:
  assert(2, ++i, "++i");
  goto L3;
L1:
  assert(1, ++i, "++i");
  goto L2;
LEND:
  assert(5, ++i, "++i");
}

int f71_helper_basic_switch(int x) {
  int ret = -1;
  switch(x) {
    case 1:
      ret = 10;
      break;
    case 2:
      ret = 20;
      break;
    default:
      ret = 30;
      break;
  }

  return ret;
}

int f71_helper_no_default(int x) {
  int ret = -1;
  switch(x) {
    case 1:
      ret = 10;
      break;
    case 2:
      ret = 20;
      break;
  }

  return ret;
}

int f71_helper_fall_through(int x) {
  int ret = 0;
  switch(x) {
    case 1:
      ret += 10;
    case 2:
      ret += 20;
    default:
      ret += 30;
  }

  return ret;
}

void f71_switch_test() {
  // 基本パターン
  assert(10, f71_helper_basic_switch(1), "f71_helper_basic_switch(1)");
  assert(20, f71_helper_basic_switch(2), "f71_helper_basic_switch(1)");
  assert(30, f71_helper_basic_switch(3), "f71_helper_basic_switch(1)");

  // デフォルト無しパターン
  assert(10, f71_helper_no_default(1), "f71_helper_no_default(1)");
  assert(20, f71_helper_no_default(2), "f71_helper_no_default(1)");
  assert(-1, f71_helper_no_default(3), "f71_helper_no_default(1)");

  // フォールスルーするパターン
  assert(60, f71_helper_fall_through(1), "f71_helper_fall_through(1)");
  assert(50, f71_helper_fall_through(2), "f71_helper_fall_through(1)");
  assert(30, f71_helper_fall_through(3), "f71_helper_fall_through(1)");
}

void f72_shift_op_test() {
  int x = 0b01;

  assert(0b10, x << 1, "x << 1");
  assert(0b100, x << 2, "x << 2");
  assert(0, x >> 1, "x >> 1");

  // 符号付きcharの-128
  char c = 0b10000000;
  char c1 = c << 1;

  // char型に代入すると桁あふれで0になる
  assert(0, c1 << 1, "c1 << 1");

  // 代入せずに計算するだけなら64bit扱いなので-256になる
  assert(-256, c << 1, "c << 1");

  //算術右シフトなので、-64になる
  assert(-64, c >> 1, "c >> 1");

  // 代入演算子の方も確認
  char c2 = 0b10000000;
  c2 <<= 1;
  assert(0, c2, "c2");

  char c3 = 0b10000000;
  c3 >>= 1;
  assert(-64, c3, "c3");
}

int f73_complex_ternary_op(int x) {
  return x == 1 ? 10 : x == 2 ? 20 : 30;
}

void f73_ternary_op_test() {
  assert(2, (1 ? 2 : 3), "1 ? 2 : 3");
  assert(3, (0 ? 2 : 3), "1 ? 2 : 3");
  assert(2, (1 || 0 ? 2 : 3), "1 || 0 ? 2 : 3");
  assert(3, (0 || 0 ? 2 : 3), "1 || 0 ? 2 : 3");

  assert(10, f73_complex_ternary_op(1),"f73_complex_ternary_op(1)");
  assert(20, f73_complex_ternary_op(2),"f73_complex_ternary_op(2)");
  assert(30, f73_complex_ternary_op(3),"f73_complex_ternary_op(3)");

  int i;
  assert(2, (i = 10 ? 2 : 3), "i = 10 ? 2 : 3");
  // iに10が代入されたわけではない
  assert(2, i, "i");

  assert(3, (i =  0 ? 2 : 3), "i = 0 ? 2 : 3");
  // iに0が代入されたわけではない
  assert(3, i, "i");
}

void f74_const_expr_test() {
  int x[1+2] = {1, 2, 3};
  assert(2, x[1], "x[1]");

  int y = 0;
  switch(x[2]) {
    case 1:
      y = 10;
      break;
    case 1 * 2:
      y = 20;
      break;
    case 1 + 2:
      y = 30;
      break;
    default:
      y = 40;
      break;
  }
  assert(30, y, "y");
}

void f75_initialize_zero_if_suppressed_initializer_test() {
  int y[3] = {};
  assert(0, y[0], "y[0]");
  assert(0, y[1], "y[1]");
  assert(0, y[2], "y[2]");

  int y[3] = {5, 6};
  assert(5, y[0], "y[0]");
  assert(6, y[1], "y[1]");
  assert(0, y[2], "y[2]");

  int x[3][4] = {
    {1, 2, 3},
    {}
  };

  assert(1, x[0][0], "x[0][0]");
  assert(2, x[0][1], "x[0][1]");
  assert(3, x[0][2], "x[0][2]");
  assert(0, x[0][3], "x[0][3]");

  assert(0, x[1][0], "x[1][0]");
  assert(0, x[1][1], "x[1][1]");
  assert(0, x[1][2], "x[1][2]");
  assert(0, x[1][3], "x[1][3]");

  assert(0, x[2][0], "x[2][0]");
  assert(0, x[2][1], "x[2][1]");
  assert(0, x[2][2], "x[2][2]");
  assert(0, x[2][3], "x[2][3]");

}

void f76_string_initializer_test() {
  char ary[3] = "xyz";
  assert('x', ary[0], "ary[0]");
  assert('y', ary[1], "ary[1]");
  assert('z', ary[2], "ary[2]");

  char ary2[5] = "xyz";
  assert('x', ary2[0], "ary2[0]");
  assert('y', ary2[1], "ary2[1]");
  assert('z', ary2[2], "ary2[2]");
  assert(0,   ary2[3], "ary2[2]");
  assert(0,   ary2[4], "ary2[2]");

  char ary23[2][3] = {
    "abc",
    "def"
  };
  assert('a', ary23[0][0], "ary23[0][0]");
  assert('b', ary23[0][1], "ary23[0][1]");
  assert('c', ary23[0][2], "ary23[0][2]");
  assert('d', ary23[1][0], "ary23[1][0]");
  assert('e', ary23[1][1], "ary23[1][1]");
  assert('f', ary23[1][2], "ary23[1][2]");
}

void f77_omitted_array_size_with_initializer_test() {
  int a[] = {1, 2, 3, 4};
  assert(1, a[0], "a[0]");
  assert(2, a[1], "a[1]");
  assert(3, a[2], "a[2]");
  assert(4, a[3], "a[3]");
  assert(16, sizeof(a), "sizeof(a))");

  long b[][2] = {
    {1, 2},
    {3, 4},
    {5, 6}
  };
  assert(1, b[0][0], "b[0][0]");
  assert(2, b[0][1], "b[1][0]");
  assert(3, b[1][0], "b[0][1]");
  assert(4, b[1][1], "b[1][1]");
  assert(5, b[2][0], "b[0][2]");
  assert(6, b[2][1], "b[1][2]");
  assert(48, sizeof(b), "sizeof(b)");
}

void f78_struct_initializer_in_local_var_test() {
  struct {
    int a;
    int b;
  } x = {4, 5};

  assert(4, x.a, "x.a");
  assert(5, x.b, "x.b");

  struct {
    int a;
    char b[3];
  } y = {
    2,
    "abc",
  };

  assert(2, y.a, "y.a");
  assert('a', y.b[0], "y.b[0]");
  assert('b', y.b[1], "y.b[1]");
  assert('c', y.b[2], "y.b[2]");
}

int f79_gvar1 = 1 + 2 + 3;
int *f79_gvar2 = &f79_gvar1;
char *f79_gvar3 = "12345";
int f79_gvar4[5] = {1, 2, 3, 4, 5};
char f79_gvar5[] = {1, 2, 3, 4};
struct {
  char a;
  int  b;
} f79_gvar6 = {2, 3};

struct {
  char a;
  int  b;
} f79_gvar7[] = {
  {2, 3},
  {4, 5}
};

void f79_gvar_initializer_test() {
  assert(6, f79_gvar1, "f79_gvar1");
  assert(6, *f79_gvar2, "*f79_gvar2");

  f79_gvar1 = 5;
  // 指してる側も変わる
  assert(5, *f79_gvar2, "*f79_gvar2");
  assert(0, strcmp(f79_gvar3, "12345"), "strcmp(f79_gvar3)");

  assert(1, f79_gvar4[0], "f79_gvar4[0]");
  assert(2, f79_gvar4[1], "f79_gvar4[1]");
  assert(3, f79_gvar4[2], "f79_gvar4[2]");
  assert(4, f79_gvar4[3], "f79_gvar4[3]");
  assert(5, f79_gvar4[4], "f79_gvar4[4]");

  assert(1, f79_gvar5[0], "f79_gvar5[0]");
  assert(2, f79_gvar5[1], "f79_gvar5[1]");
  assert(3, f79_gvar5[2], "f79_gvar5[2]");
  assert(4, f79_gvar5[3], "f79_gvar5[3]");

  assert(2, f79_gvar6.a, "f79_gvar6.a");
  assert(3, f79_gvar6.b, "f79_gvar6.b");

  assert(2, f79_gvar7[0].a, "f79_gvar7[0].a");
  assert(3, f79_gvar7[0].b, "f79_gvar7[0].b");
  assert(4, f79_gvar7[1].a, "f79_gvar7[1].a");
  assert(5, f79_gvar7[1].b, "f79_gvar7[1].b");

}

int f80_gvar1[][2] = {1, 2, 3, 4, 5, 6};
struct {
  char a;
  int  b;
  long c;
} f80_gvar2[] = {
  1, 2, 3,
  4, 5, 6,
  7, 8, 9
};

int f80_gvar3[3][3] = {
  {1},
  {4, 5, 6, 7}, // この最後の7は[2][0]にいくのではなく、単に捨てられる
};

struct {
  int a;
  int b;
  int c;
} f80_gvar4 = {1, 2, 3, 4}; // 4が捨てられる
void f80_gvar_initializer_no_brace_test() {
  assert(1, f80_gvar1[0][0], "f80_gvar1[0][0]");
  assert(2, f80_gvar1[0][1], "f80_gvar1[0][1]");
  assert(3, f80_gvar1[1][0], "f80_gvar1[1][0]");
  assert(4, f80_gvar1[1][1], "f80_gvar1[1][1]");
  assert(5, f80_gvar1[2][0], "f80_gvar1[2][0]");
  assert(6, f80_gvar1[2][1], "f80_gvar1[2][1]");

  assert(1, f80_gvar2[0].a, "f80_gvar2[0].a");
  assert(2, f80_gvar2[0].b, "f80_gvar2[0].b");
  assert(3, f80_gvar2[0].c, "f80_gvar2[0].c");
  assert(4, f80_gvar2[1].a, "f80_gvar2[1].a");
  assert(5, f80_gvar2[1].b, "f80_gvar2[1].b");
  assert(6, f80_gvar2[1].c, "f80_gvar2[1].c");
  assert(7, f80_gvar2[2].a, "f80_gvar2[2].a");
  assert(8, f80_gvar2[2].b, "f80_gvar2[2].b");
  assert(9, f80_gvar2[2].c, "f80_gvar2[2].c");

  assert(1, f80_gvar3[0][0], "f80_gvar3[0][0]");
  assert(0, f80_gvar3[0][1], "f80_gvar3[0][1]");
  assert(0, f80_gvar3[0][2], "f80_gvar3[0][2]");
  assert(4, f80_gvar3[1][0], "f80_gvar3[1][0]");
  assert(5, f80_gvar3[1][1], "f80_gvar3[1][1]");
  assert(6, f80_gvar3[1][2], "f80_gvar3[1][2]");
  assert(0, f80_gvar3[2][0], "f80_gvar3[2][0]");
  assert(0, f80_gvar3[2][1], "f80_gvar2[2][1]");
  assert(0, f80_gvar3[2][2], "f80_gvar2[2][2]");

  assert(1, f80_gvar4.a, "f80_gvar4.a");
  assert(2, f80_gvar4.b, "f80_gvar4.b");
  assert(3, f80_gvar4.c, "f80_gvar4.c");

  int f80_lvar1[][2] = {1, 2, 3, 4, 5, 6};
  assert(1, f80_lvar1[0][0], "f80_lvar1[0][0]");
  assert(2, f80_lvar1[0][1], "f80_lvar1[0][1]");
  assert(3, f80_lvar1[1][0], "f80_lvar1[1][0]");
  assert(4, f80_lvar1[1][1], "f80_lvar1[1][1]");
  assert(5, f80_lvar1[2][0], "f80_lvar1[2][0]");
  assert(6, f80_lvar1[2][1], "f80_lvar1[2][1]");

  struct {
    char a;
    int  b;
    long c;
  } f80_lvar2[] = {
    1, 2, 3,
    4, 5, 6,
    7, 8, 9
  };
  assert(1, f80_lvar2[0].a, "f80_lvar2[0].a");
  assert(2, f80_lvar2[0].b, "f80_lvar2[0].b");
  assert(3, f80_lvar2[0].c, "f80_lvar2[0].c");
  assert(4, f80_lvar2[1].a, "f80_lvar2[1].a");
  assert(5, f80_lvar2[1].b, "f80_lvar2[1].b");
  assert(6, f80_lvar2[1].c, "f80_lvar2[1].c");
  assert(7, f80_lvar2[2].a, "f80_lvar2[2].a");
  assert(8, f80_lvar2[2].b, "f80_lvar2[2].b");
  assert(9, f80_lvar2[2].c, "f80_lvar2[2].c");

  int f80_lvar3[3][3] = {
    {1},
    {4, 5, 6, 7}, // この最後の7は[2][0]にいくのではなく、単に捨てられる
  };
  assert(1, f80_lvar3[0][0], "f80_lvar3[0][0]");
  assert(0, f80_lvar3[0][1], "f80_lvar3[0][1]");
  assert(0, f80_lvar3[0][2], "f80_lvar3[0][2]");
  assert(4, f80_lvar3[1][0], "f80_lvar3[1][0]");
  assert(5, f80_lvar3[1][1], "f80_lvar3[1][1]");
  assert(6, f80_lvar3[1][2], "f80_lvar3[1][2]");
  assert(0, f80_lvar3[2][0], "f80_lvar3[2][0]");
  assert(0, f80_lvar3[2][1], "f80_lvar2[2][1]");
  assert(0, f80_lvar3[2][2], "f80_lvar2[2][2]");

  struct {
    int a;
    int b;
    int c;
  } f80_lvar4 = {1, 2, 3, 4}; // 4が捨てられる
  assert(1, f80_lvar4.a, "f80_lvar4.a");
  assert(2, f80_lvar4.b, "f80_lvar4.b");
  assert(3, f80_lvar4.c, "f80_lvar4.c");
}

char f81_gvar1[] = "abc";
char f81_gvar2[2] = "abc";
char f81_gvar3[5] = "abc";

void f81_gvar_char_array_literal_initializer() {
  assert(0, strcmp(f81_gvar1, "abc"), "strcmp(f81_gvar1, \"abc\")");

  assert('a', f81_gvar2[0], "f81_gvar2[0]");
  assert('b', f81_gvar2[1], "f81_gvar2[1]");

  assert('a', f81_gvar3[0], "f81_gvar3[0]");
  assert('b', f81_gvar3[1], "f81_gvar3[1]");
  assert('c', f81_gvar3[2], "f81_gvar3[2]");
  assert(0,   f81_gvar3[3], "f81_gvar3[3]");
  assert(0,   f81_gvar3[4], "f81_gvar3[4]");
}

char f82_gvar1[] = "abcdef";
char *f82_gvar2 = f82_gvar1;
char *f82_gvar3 = &f82_gvar1;
char *f82_gvar4 = f82_gvar1 + 2;
void f82_pointer_add_sub_initializer() {
  assert(0 ,strcmp(f82_gvar2, "abcdef"), "strcmp(f82_gvar2, \"abcdef\")");
  assert(0 ,strcmp(f82_gvar3, "abcdef"), "strcmp(f82_gvar3, \"abcdef\")");
  assert(0 ,strcmp(f82_gvar4, "cdef"), "strcmp(f82_gvar4, \"cdef\")");
}

void f83_void_function_param_definition(void) {
  // 関数の仮引数の定義がvoidの場合でもえらーにならないテスト
}

extern int f84_ext1;
extern int *f84_ext2;
void f84_extern_global_var_test() {
  f84_ext1 = 5;
  f84_ext2 = &f84_ext1;

  assert(5, f84_ext1, "f84_ext1");
  assert(5, *f84_ext2, "*f84_ext2");
}


// これはもちろん合法
struct hoge {
  int a;
  int b;
};

// これも実は合法。上の構造体のタグの宣言のみを許したら意図せず組込みの型のみの宣言もゆるしてしまったパターン？
int;

void f85_toplevel_typename_only_decl_test() {
  struct hoge x = {1, 2};

  assert(1, x.a, "x.a");
  assert(2, x.b, "x.b");
}

void f86_empty_statement_test() {
  ;
}

void f87_alignof_test() {
  assert(1, _Alignof(char), "_Alignof(char)");
  assert(2, _Alignof(short), "_Alignof(short)");
  assert(4, _Alignof(int), "_Alignof(int)");
  assert(8, _Alignof(long), "_Alignof(long)");
  assert(8, _Alignof(long long), "_Alignof(long long)");
  assert(8, _Alignof(int*), "_Alignof(*int)");
  assert(4, _Alignof(int[]), "_Alignof(int[])");
  assert(1, _Alignof(struct { char a; char b;}), "_Alignof(struct { char a; char b;})");
  assert(4, _Alignof(struct { char a; int b;}), "_Alignof(struct { char a; int b;})");
  assert(4, _Alignof(struct { char a; int b;}[4]), "_Alignof(struct { char a; int b;}[4])");
}

int f88_test() {
  static int f88_i = 1;
  static int f88_j;

  f88_j = f88_i++;
  return f88_j;
}

int f88_test2() {
  static int f88_i = 1, *f88_j = &f88_i, *f88_k;

  f88_k = f88_j;
  *f88_k += 1;

  return f88_i;
}

void f88_static_var_test() {
  assert(1, f88_test(), "f88_test()");
  assert(2, f88_test(), "f88_test()");
  assert(3, f88_test(), "f88_test()");

  assert(2, f88_test2(), "f88_test2()");
  assert(3, f88_test2(), "f88_test2()");
  assert(4, f88_test2(), "f88_test2()");
}

typedef struct f84_tree {
  int val;
  struct f84_tree *lhs;
  struct f84_tree *rhs;
} f84_tree;

f84_tree *f84_tree_var = &(f84_tree) {
  1,
  &(f84_tree) {
    2,
    &(f84_tree) { 3, 0, 0 },
    &(f84_tree) { 4, 0, 0 },
  },
  0,
};

void f89_compound_literal_test() {
  assert(1, f84_tree_var->val, "f84_tree_var->val");
  assert(2, f84_tree_var->lhs->val, "f84_tree_var->lhs->val");
  assert(3, f84_tree_var->lhs->lhs->val, "f84_tree_var->lhs->lhs->val");
  assert(4, f84_tree_var->lhs->rhs->val, "f84_tree_var->lhs->rhs->val");

  int i = (int){1};
  assert(1, i, "i");

  int j = ((int[]){0, 1, 2})[2];
  assert(2, j, "j");

  char k = ((struct { char a; int b;}){'a', 3}).a;
  char l = ((struct { char a; int b;}){'a', 3}).b;
  assert('a', k, "k");
  assert(3, l, "l");

  int m = 2;
  int n = (int) { m };
  assert(2, n, "n");
}

int main() {
  test_count = 0;
  ok_count = 0;

  assert(0 , 0, "0");
  assert(42, 42, "42");
  assert(21, 5+20-4, "5+20-4");
  assert(41, 12 + 34 - 5 , "12 + 34 - 5 ");
  assert(47, 5+6*7, "5+6*7");
  assert(15, 5 * (9- 6), "5 * (9- 6)");
  assert(4 , ( 3 + 5) / 2, "( 3 + 5) / 2");
  assert(60, (1 + 2) * 3 + 4 + (5 + 6 * 7), "(1 + 2) * 3 + 4 + (5 + 6 * 7)");
  assert(5 , -1 + 2 * 3, "-1 + 2 * 3");
  assert(5 , -1 + +2 * 3, "-1 + +2 * 3");
  assert(12, -(-1 + -2) * 4, "-(-1 + -2) * 4");
  assert(0 , 0==1, "0==1");
  assert(1 , 42==42, "42==42");
  assert(1 , 0!=1, "0!=1");
  assert(0 , 42!=42, "42!=42;");
  assert(1 , 0<1, "0<1");
  assert(0 , 1<1, "1<1");
  assert(0 , 2<1, "2<1");
  assert(1 , 0<=1, "0<=1");
  assert(1 , 1<=1, "1<=1");
  assert(0 , 2<=1, "2<=1");
  assert(1 , 1>0, "1>0");
  assert(0 , 1>1, "1>1");
  assert(0 , 1>2, "1>2");
  assert(1 , 1>=0, "1>=0");
  assert(1 , 1>=1, "1>=1");
  assert(0 , 1>=2, "1>=2");
  {int a; a = 10; assert(10, a, "int a; a = 10");}
  {int a; int b; a=10;b=a; assert(11, b + 1, "int a; int b; a=10;b=a; b + 1");}
  {int a; int b; a=b=10; a+b; assert(20, a + b, "{int a; int b; a=b=10; a+b}");}
  {int a; int b; a = 1 + 2; b = 3 * 4; a + b; assert(15, a + b, "int a; int b; a = 1 + 2; b = 3 * 4; a + b");}
  {int foo; int bar; foo = 1 + 2; bar = 3 * 4; assert(15, foo + bar, "int foo; int bar; foo = 1 + 2; bar = 3 * 4; foo + bar");}
  {int foo; int boo; int a; a=foo=1; boo = a + foo; boo == 2; assert(1, boo == 2, "int foo; int boo; int a; a=foo=1; boo = a + foo; boo == 2;");}
  {int b; int boo; b=boo =1; b + boo + 2; assert(4, b + boo + 2, "int b; int boo; b=boo =1; b + boo + 2");}
  assert(10, f1_while(), "f1_while()");
  assert(30, f2_while(), "f2_while()");
  assert(11, f3_if(), "f3_if()");
  assert(12, f4_if(), "f4_if()");
  assert(13, f5_if(), "f5_if()");
  assert(12, f6_if(), "f6_if()");
  assert(13, f7_if(), "f7_if()");
  assert(11, f8_if(), "f8_if()");
  assert(4, f9_while_if(), "f9_while_if()");
  assert(5, f10_while_if(), "f10_while_if()");
  assert(11, f11_return(), "f11_return()");
  assert(45, f12_for(), "f12_for()");
  assert(45, f13_for(), "f13_for()");
  assert(45, f14_for(), "f14_for()");

  assert(2, foo_return2(), "foo_return2()");
  assert(4, 2 + foo_return2(), "2 + foo_return2()");
  assert(5, foo_with_args_add(2, 3), "foo_with_args_add(2, 3)");
  assert(10, f15_call_func(), "f15_call_func()");
  assert(21, foo_with_args_add6(1, 2, 3, 4, 5, 6), "foo_with_args_add6(1, 2, 3, 4, 5, 6)");
  assert(120, fact(5), "fact(5)");
  assert(55, fib(10), "fib(10)");
  assert(1, f16_for_while_if_func_arg(2, 3), "f16_for_while_if_func_arg(2, 3)");

  {int foo; foo = 3; assert(3, *&foo, "int foo; foo = 3; *&foo;");}
  {int foo; int *boo; foo = 3; boo = &foo; assert(3, *boo, "int foo; int *boo; foo = 3; boo = &foo; *boo");}
  {int a; int b;int c;int *d; a = 4; b = 5; c = 6; d = &a + 1; assert(5, *d, "{int a; int b;int c;int *d; a = 4; b = 5; c = 6; d = &a + 1; *d; }");}
  {int a; int b; int c; int *d; a = 4; b = 5; c = 6; d = &c - 1; assert(5, *d, "{int a; int b; int c; int *d; a = 4; b = 5; c = 6; d = &c - 1; }");}
  {int a; int b; int c; a = 4; b = 5; c = 6; *(&c - 1) = 12; assert(12, b, "{int a; int b; int c; a = 4; b = 5; c = 6; *(&c - 1) = 12; }");}
  {int x; x=3; *&x; assert(3, *&x, "{int x; x=3; *&x;}");}
  {int x; int *y; int **z;x=3; y=&x; z=&y; assert(3, **z, "{int x; int *y; int **z;x=3; y=&x; z=&y; }");}
  {int x; int y; x=3; y=5; assert(5, *(&x+1), "{int x; int y; x=3; y=5; }");}
  {int x; int y; x=3; y=5; assert(3, *(&y-1), "{int x; int y; x=3; y=5; }");}
  {int x; int *y; x=3; y=&x; *y=5; assert(5, x, "{int x; int *y; x=3; y=&x; *y=5; }");}
  {int x; int y; x=3; y=5; *(&x+1)=7; assert(7, y, "{int x; int y; x=3; y=5; *(&x+1)=7; }");}
  {int x; int y; x=3; y=5; *(&y-1)=7; assert(7, x, "{int x; int y; x=3; y=5; *(&y-1)=7; }");}

  assert(23, f17_pointer(), "f17_pointer()");

  {int *p; alloc_3num_ary_8_byte_cell(&p); assert(3, *(p + 1), "int *p; alloc_3num_ary_8_byte_cell(&p); *(p + 1);"); }
  {int *p; alloc_3num_ary_8_byte_cell(&p); assert(4, *(2 + p), "int *p; alloc_3num_ary_8_byte_cell(&p); return *(2 + p)"); }
  {int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = p + 3; assert(3, q - p, "int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = q + 3; q - p;"); }
  {int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = p + 3; assert(4, *(q - 1), "int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = q + 3; *(q - 1);"); }

  assert(8, sizeof(1), "sizeof(1)");
  { int x;
    int *y;
    int **z;
    assert(4, sizeof(x), "sizeof(x)");
    assert(8, sizeof(&x), "sizeof(&x)");
    assert(8, sizeof(y), "sizeof(y)");
    assert(8, sizeof(1 + 2), "sizeof(1 + 2)");
    assert(8, sizeof z, "sizeof z");
    assert(8, sizeof(sizeof(0)), "sizeof(sizeof(0))");
    assert(8, sizeof sizeof &x, "sizeof sizeof &x");
  }

  assert(3, f18_ary(), "f18_ary()");
  assert(6, f19_ary(), "f19_ary()");
  assert(6, f20_ary(), "f20_ary()");

  {int x[2][3]; int *y; y = x; *y=0;     assert(0, **x, "int x[2][3]; int *y; y = x; *y=0;*y=0; ");}
  {int x[2][3]; int *y; y = x; *(y+1)=1; assert(1, *(*x+1), "int x[2][3]; int *y; y = x; *(y+1)=1; *(y+1)=1;");}
  {int x[2][3]; int *y; y = x; *(y+2)=2; assert(2, *(*x+2), "int x[2][3]; int *y; y = x; *(y+2)=2; *(y+2)=2;");}
  {int x[2][3]; int *y; y = x; *(y+3)=3; assert(3, **(x+1), "int x[2][3]; int *y; y = x; *(y+3)=3; *(y+3)=3;");}
  {int x[2][3]; int *y; y = x; *(y+4)=4; assert(4, *(*(x+1)+1), "int x[2][3]; int *y; y = x; *(y+4)=4; *(y+4)=4;");}
  {int x[2][3]; int *y; y = x; *(y+5)=5; assert(5, *(*(x+1)+2), "int x[2][3]; int *y; y = x; *(y+5)=5; *(y+5)=5;");}
  {int x[2][3]; int *y; y = x; *(y+6)=6; assert(6, **(x+2), "int x[2][3]; int *y; y = x; *(y+6)=6; *(y+6)=6;");}

  assert(21, f21_ary(), "f21_ary()");
  assert(0, f22_x, "f22_x");
  {f23_x_test(5); assert(5, f23_x, "f23_x_test(5); f23_x;");}
  assert(6, f24_helper(), "f24_helper()");
  assert(12, f25_helper(), "f25_helper()");
  {char x; assert(1, sizeof(x), "char x; sizeof(x)");}
  {char x[10]; assert(10, sizeof(x), "char x[10]; sizeof(x)");}
  assert(5, f26_char(), "f26_char()");
  assert(5, f27_helper(), "f27_helper()");
  assert(1, f28_sub_char(7, 3, 3), "f28_sub_char(7, 3, 3);");
  assert(97, "abc"[0], "\"abc\"[0]");
  assert(98, "abc"[1], "\"abc\"[1]");
  assert(99, "abc"[2], "\"abc\"[2]");
  assert(0, "abc"[3], "\"abc\"[3]");
  assert(10, "\n"[0], "\"\\n\"[0]");
  assert(9, "\t"[0], "\"\\t\"[0]");
  assert(34, "\""[0], "\"\\\"\"[0]");
  assert(92, "\\"[0], "\"\\\\\"[0]");

  assert(0, 4 % 2, "4 % 2");
  assert(1, 4 % 3, "4 % 3");
  assert(2, 5 % 3, "5 % 3");

  // this line is single line comment
  /*
    this
    area
    is
    block
    comment
    */
  assert(3, 1 + 2, "1 + 2");
  assert(56, f29_initialize_local_var(), "f29_initialize_local_var()");
  assert(15, f30_struct_member(), "f30_struct_member()");

  // 型のサイズだけでいうと5バイトだが、int(4バイト)とcharが混在しているため、
  // int側のアラインメントに合わされて構造体
  struct {
    int x;
    char y;
  } s1;
  assert(8, sizeof(s1), "sizeof(s1)");

  struct {
    char x;
    int y;
  } s2;
  assert(8, sizeof(s2), "sizeof(s2)");

  struct {
    char x;
    char y;
  } s3;
  assert(2, sizeof(s3), "sizeof(s3)");

  struct {
    int x;
    int y;
  } s4;
  assert(8, sizeof(s4), "sizeof(s4)");

  assert(1, f31_local_variable_alignment(), "f31_local_variable_alignment()");
  assert(7, f32_local_variable_alignment(), "f32_local_variable_alignment()");
  assert(36, f33_use_struct_tag(), "f33_use_struct_tag()");
  assert(10, f34_arrow_operator(), "f34_arrow_operator()");
  assert(60, f35_typedef_stmt(), "f35_typedef_stmt()");
  assert(3, f36_global_typedef(), "f36_global_typedef()");
  assert(2, f37_fix_char_mov(), "f37_fix_char_mov()");

  long f38_val;
  assert(8, sizeof(f38_val), "sizeof(f38_val)");
  assert(16, f39_struct_included_long(), "f39_struct_included_long()");

  short f40_val;
  assert(2, sizeof(f40_val), "sizeof(f40_val)");
  assert(34, f41_long_short_int_char_args(10, 9, 8, 7), "f41_long_short_int_char_args(10, 9, 8, 7)");

  assert(21, f42_use_all_argument_register_short(1, 2, 3, 4, 5, 6), "use_all_argument_register_short(1, 2, 3, 4, 5, 6)");
  assert(21, f42_use_all_argument_register_int(1, 2, 3, 4, 5, 6), "use_all_argument_register_short(1, 2, 3, 4, 5, 6)");
  assert(21, f42_use_all_argument_register_char(1, 2, 3, 4, 5, 6), "use_all_argument_register_short(1, 2, 3, 4, 5, 6)");
  f43_nested_decl();
  assert(3, f44_hogehoge(1, 2), "f44_hogehoge(1, 2)");

  f45_call_void_func();
  f46_bool_test();
  f47_long_long();
  f48_complex_decl();
  f49_sizeof_type_argument();
  f50_large_number_literal();
  f51_unary_test();
  f52_cast_test();
  f53_char_literal_test();
  f54_enum_test();
  f55_for_var_decl_test();
  f56_coma_test();
  f57_multi_var_decl_test();
  f58_inc_dec_test();
  f59_assign_with_operator_test();
  f60_hex_octal_number_test();
  f61_not_operator_test();
  f62_bit_not_operator_test();
  f63_bit_binary_op_test();
  f64_logical_adn_or_test();
  f65_array_arg_as_pointer_test();
  f66_fix_struct_decl_test();
  f67_improve_struct_decl_test();
  f68_break_test();
  f69_continue_test();
  f70_goto_test();
  f71_switch_test();
  f72_shift_op_test();
  f73_ternary_op_test();
  f74_const_expr_test();
  f75_initialize_zero_if_suppressed_initializer_test();
  f76_string_initializer_test();
  f77_omitted_array_size_with_initializer_test();
  f78_struct_initializer_in_local_var_test();
  f79_gvar_initializer_test();
  f80_gvar_initializer_no_brace_test();
  f81_gvar_char_array_literal_initializer();
  f82_pointer_add_sub_initializer();
  f83_void_function_param_definition();
  f84_extern_global_var_test();
  f85_toplevel_typename_only_decl_test();
  f86_empty_statement_test();
  f87_alignof_test();
  f88_static_var_test();
  f89_compound_literal_test();

  //------------------------------------------------------------------------
  // ここより上にテストを書く
  printf("total: %d tests, %d ok\n", test_count, ok_count);
  if (test_count == ok_count) {
    return 0;
  } else {
    return 1;
  }
}

