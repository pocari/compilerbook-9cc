// vim:set ft=c:
int test_count;
int ok_count;

int printf();

// test_func.c
int foo_with_args_add(int a, int b);
int foo_with_args_add6(
    int a1,
    int a2,
    int a3,
    int a4,
    int a5,
    int a6
);
int foo_return2();
// TODO: 戻り値voidだがまだvoid実装してないので一旦int型で宣言しておく
int alloc_3num_ary_8_byte_cell(int **p);

int assert(int expected, int actual, char *code) {
  test_count = test_count + 1;
  if (expected == actual) {
    ok_count = ok_count + 1;
    printf("%s => %d\n", code, actual);
  } else {
    printf("%s => %d expected, but got %d\n", code, expected, actual);
  }
}
int f1_while() {
  int i;
  i = 0;
  while (i < 10)
    i = i + 1;
  return i;
}

int f2_while() {
  int i;
  int sum;
  i = 0;
  sum = 0;
  while (i < 10) {
    sum = sum + 3;
    i = i + 1;
  }
  return sum;
}
int f3_if() {
  int foo;
  foo = 1;
  if (foo == 1) {
    return 11;
  }
  return 12;
}

int f4_if() {
  int foo;
  foo = 2;
  if (foo == 1) {
    return 11;
  } else if (foo == 2) {
    return 12;
  } else {
    return 13;
  }
  return 14;
}

int f5_if() {
  int foo;
  foo = 3;
  if (foo == 1) {
    return 11;
  } else if (foo == 2) {
    return 12;
  } else {
    return 13;
  }
  return 14;
}

int f6_if() {
  int foo;
  foo = 0;
  if (foo == 1) {
    return 11;
  }
  return 12;
}

int f7_if() {
  int foo;
  foo = 0;
  if (foo == 1) {
    return 11;
  } else {
    return 13;
  }
  return 12;
}

int f8_if() {
  int foo;
  foo = 1;
  if (foo == 1) {
    return 11;
  } else {
    return 13;
  }
  return 12;
}

int f9_while_if() {
  int sum;
  int i;
  i = 0;
  sum = 0;
  while (i < 10) {
    sum = sum + 2;
    i = i + 1;
  }
  if (sum == 20) {
    return 4;
  } else {
    return 5;
  }
}

int f10_while_if() {
  int i;
  int sum;

  i = 0;
  sum = 0;
  while (i < 10) {
    sum = sum + 2;
    i = i + 1;
  }
  if (sum != 20) {
    return 4;
  } else {
    return 5;
  }
}

int f11_return() {
  int returnx; returnx = 11; return returnx;
}

int f12_for() {
  int sum;
  int i;
  sum = 0;
  for (i = 0; i < 10; i = i + 1) {
    sum = sum + i;
  }
  return sum;
}

int f13_for() {
  int sum;
  int i;
  sum = 0;
  i = 0;
  for (; i < 10; i = i + 1) {
    sum = sum + i;
  }
  return sum;
}

int f14_for() {
  int sum;
  int i;
  sum = 0;
  i = 0;
  for (; i < 10;) {
    sum = sum + i;
    i = i + 1;
  }
  return sum;
}

int f15_call_func() {
  int foo;
  int bar;
  foo = 1;
  bar = 2;
  return foo_with_args_add(foo + bar, 3 + 4);
}

int fact(int n) {
  if (n == 1) {
    return 1;
  } else {
    return fact(n - 1) * n;
  }
}

int fib(int n) {
  if (n == 1) {
    return 1;
  } else {
    if (n == 2) {
      return 1;
    } else {
      return fib(n - 1) + fib(n - 2);
    }
  }
}

int f16_for_while_if_func_arg(int a, int b) {
  int i;
  int j;
  int a;
  int b;
  for (i = 0; i < 10; i = i + 1) {
    a = a + 1;
  }
  j = 0;
  while (j < 10) {
    b = b + 1;
    j = j + 1;
  }
  if (a + b > 0) {
    return 1;
  } else {
    return 0;
  }
}

int f17_pointer() {
  int x;
  int *y;
  int **z;

  x = 12;
  y = &x;
  z = &y;

  **z = 23;

  return x;
}

int f18_ary() {
  int a[2];
  *a = 1;
  *(a + 1) = 2;
  int *p;
  p = a;
  return *p + *(p + 1);
}

int f19_ary() {
  int a[2];
  a[0] = 1;
  a[1] = 2;
  int *p;
  p = a;
  return *p + *(p + 1) + a[1 - 1] + a[0 + 1];
}

int f20_ary_helper() {
  return 2;
}

int f20_ary() {
  int a[2];
  a[0] = 1;
  a[1] = 2;
  int *p;
  p = a;
  return *p + *(p + 1) + 0[a] + (-1 + f20_ary_helper())[a];
}

int f21_ary() {
  int a[2][3];
  int *p;

  a[0][0] = 1;
  a[0][1] = 2;
  a[0][2] = 3;
  a[1][0] = 4;
  a[1][1] = 5;
  a[1][2] = 6;

  p = a + 1;

  return a[0][0] + a[0][1] + a[0][2] + *p + *(p + 1) + *(p + 2);
}

int f22_x;

int f23_x;
int f23_x_test(int n) {
  f23_x = n;
}

int f24_x[3];
int f24_helper() {
  f24_x[0] = 1;
  f24_x[1] = 2;
  f24_x[2] = 3;
  int *p;
  p = f24_x;
  return *p + *(p + 1) + *(p + 2);
}

int *f25_x;
int f25_helper() {
  int y;
  y = 12;
  f25_x = &y;
  return *f25_x;
}

int f26_char() {
  char x[3];
  x[0] = 1;
  x[1] = 2;
  char y;
  y = 4;
  return x[0] + y;
}

char f27_x[2];
int f27_helper() {
  f27_x[0] = 2;
  f27_x[1] = 3;
  return f27_x[0] + f27_x[1];
}

int f28_sub_char(char a, char b, char c) {
  return a - b - c;
}

int f29_helper() {
  return 3;
}

int f29_initialize_local_var() {
  int x = 10;
  int *y = &x;
  int z = f29_helper();
  int hoge[2] = {2, 3};
  int foo[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int boo[2] = {hoge[0], hoge[1]};
  return x + *y + z + 2 + hoge[0] + hoge[1]
  + foo[0][0]
  + foo[0][1]
  + foo[0][2]
  + foo[1][0]
  + foo[1][1]
  + foo[1][2]
  + boo[0]
  + boo[1];
}

int f30_struct_member() {
  struct {
    int m1;
    char m2;
    int m3[2];
    int *m4;
  } x;
  int y = 5;

  x.m1 = 1;
  x.m2 = 2;
  x.m3[0] = 3;
  x.m3[1] = 4;
  x.m4 = &y;

  return
    x.m1 +
    x.m2 +
    x.m3[0] +
    x.m3[1] +
    *x.m4
    ;
}

int f31_local_variable_alignment() {
  char x;
  int y;

  // テスト用に無理やりアドレスをint型にいれる
  long a = &x;
  long b = &y;

  /*
   * スタックは現状ローカル変数の宣言の逆順にスタックに確保されるため、char, int の順で宣言するとスタック上は下記のようになる
   * -----------> スタックの伸びる方向(アドレスが小さくなる方向)
   *
   *                 int y;
   *                  |
   *                  v
   * +----------------+
   * | 4byte          |
   * +----------------+
   * ^
   * |
   * rbp
   *
   * 次にcharを積むが、charのアラインメントは1byteなので、素直にint yの上に char xの領域を確保し、下記のようになる
   *
   *                 int y;   char x;
   *                  |       |
   *                  v       v
   * +----------------+-------+
   * | 4byte          | 1byte |
   * +----------------+-------+
   * ^
   * |
   * rbp
   *
   * なので、xのアドレスとyのアドレスは1byteだけ離れている
   */
  return b - a;
}

int f32_local_variable_alignment() {
  int x;
  char y;

  // テスト用に無理やりアドレスをint型にいれる
  long a = &x;
  long b = &y;

  /*
   * スタックは現状ローカル変数の宣言の逆順にスタックに確保されるため、int, char の順で宣言するとスタック上は下記のようになる
   * -----------> スタックの伸びる方向(アドレスが小さくなる方向)
   *
   *        char y;
   *         |
   *         v
   * +-------+
   * | 1byte |
   * +-------+
   * ^
   * |
   * rbp
   *
   * 次にintを積むが、intのアラインメントは4byteなので、charの直後には積めず、4byte境界になるように調整されるので、
   * rbpからみて2個目(1個目の4の倍数の領域にはchar yがいるため)の4の倍数=rbpからみて8byteの位置にint xの両利きを確保し下記のようになる
   *
   *        char y;                    int x;
   *         |                         |
   *         v                         v
   * +-------+--------+----------------+
   * | 1byte | 3byte  | 4byte          |
   * +-------+--------+----------------+
   *         |padding |<-- xの領域  -->|
   * ^
   * |
   * rbp
   *
   * なので、xのアドレスとyのアドレスは7byte(隙間の3byte + int xのサイズの4byte)だけ離れている
   */
  return b - a;
}

int f33_use_struct_tag() {
  struct tag1 {
    int x;
    int y;
  } o;

  struct tag2 {
    int m;
    int n;
  } p;

  struct tag1 tag1_var;
  struct tag2 tag2_var;

  o.x = 1;
  o.y = 2;
  p.m = 3;
  p.n = 4;
  tag1_var.x = 5;
  tag1_var.y = 6;
  tag2_var.m = 7;
  tag2_var.n = 8;

  return o.x + o.y + p.m + p.n + tag1_var.x + tag1_var.y + tag2_var.m + tag2_var.n;
}

int f34_arrow_operator() {
  struct tag {
    int x;
    int y;
  } m;

  struct tag *n = &m;

  m.x = 2;
  n->y = 3;

  return m.x + m.y + n->x + n->y;
}

int f35_typedef_stmt() {
  int x = 10;
  typedef int hoge;
  typedef int foo;
  hoge y = 20;
  foo z = 30;

  return x + y + z;
}

typedef struct hoge_hoge {
  int x;
  int y;
} hoge_hoge;

int f36_global_typedef() {
  hoge_hoge x;
  typedef hoge_hoge *pointer_of_hoge_hoge;

  pointer_of_hoge_hoge y = &x;
  y->x = 1;
  y->y = 2;

  return x.x + x.y;
}

int f37_fix_char_mov() {
  char x = -1;
  char y = 3;

  return x + y;

}

int f39_struct_included_long() {
  struct {
    char x;
    int y;
    long z;
  } s;

  return sizeof(s);
}

int f41_long_short_int_char_args(long a, short b, int c, char d) {
  return a + b + c + d;
}
int f42_use_all_argument_register_short(short a, short b, short c, short d, short e, short f) {
  return a + b + c + d + e + f;
}

int f42_use_all_argument_register_int(int a, int b, int c, int d, int e, int f) {
  return a + b + c + d + e + f;
}

int f42_use_all_argument_register_char(char a, char b, char c, char d, char e, char f) {
  return a + b + c + d + e + f;
}

int f43_nested_decl() {
  // x は intへのポインタの配列(要素は3)
  // => 4byte * 3 = 12byte
  int *x[3];

  // y は 「intの配列(要素は4)」へのポインタ
  // => ポインタなので8byte
  int (*y)[4];

  // z は 「intの配列(要素は5)」
  // => 4byte * 5 = 20 byte
  int z[5];

  int m[2][4] = {
    {1, 2, 3, 4},
    {5, 6, 7, 8}
  };
  y = m;
  m[1][0] = 9;


  assert(24, sizeof(x), "sizeof(x)");
  assert(8, sizeof(y), "sizeof(y)");
  assert(20, sizeof(z), "sizeof(z)");


  assert(4, y[0][3], "y[0][3]");
  assert(9, y[1][0], "y[1][0]");
  assert(6, y[1][1], "y[1][1]");
}

// 宣言
int f44_hogehoge(int x, char y);

// 定義
int f44_hogehoge(int x, char y) {
  return x + y;
}

// voidのテストがよくわからないので voidの戻り値の関数内でvoid *ポインタを定義してエラーにならないことだけ確認
void f45_call_void_func() {
  void *x;
}

void f46_bool_test() {
  _Bool a = 0;
  _Bool b = 1;
  _Bool c = 2;

  assert(0, a, "a == 0");
  assert(1, b, "b == 1");
  assert(1, c, "c == 1");

  if (a) {
    assert(1, 2, "ここにはこないはず");
  } else {
    assert(1, 1, "a is false");
  }

  if (c) {
    assert(1, 1, "c is true");
  } else {
    assert(1, 2, "ここにはこないはず");
  }
}

void f47_long_long() {
  long long a = 10;
  long long *b = &a;

  assert(10, *b, "*b");
  assert(8, sizeof(a), "sizeof(a)");
}

typedef f48_global_typedef_01;
typedef char f48_global_typedef_02;
short typedef  f48_global_typedef_03;
int f48_global_var_04;
long int *f48_global_var_05;
f48_global_typedef_01 f48_global_var_06;

void f48_complex_decl() {
  int a;
  long b;
  long long c;
  long long int d;
  long int long e;
  int long long f;
  char g;
  void *h;
  short i;
  short int j;
  int short k;
  typedef typedef l;
  l m;
  long typedef n;
  n o;

  assert(4, sizeof(a), "sizeof(a)");
  assert(8, sizeof(b), "sizeof(b)");
  assert(8, sizeof(c), "sizeof(c)");
  assert(8, sizeof(d), "sizeof(d)");
  assert(8, sizeof(e), "sizeof(e)");
  assert(8, sizeof(f), "sizeof(f)");
  assert(1, sizeof(g), "sizeof(g)");
  assert(8, sizeof(h), "sizeof(h)");
  assert(2, sizeof(i), "sizeof(i)");
  assert(2, sizeof(j), "sizeof(j)");
  assert(2, sizeof(k), "sizeof(k)");
  assert(4, sizeof(m), "sizeof(m)");
  assert(8, sizeof(o), "sizeof(o)");
}

void f49_sizeof_type_argument() {
  typedef struct hoge {
    int x;
    long y;
  } hoge;

  assert(4, sizeof(int), "sizeof(int)");
  assert(8, sizeof(int *(*)[3]), "sizeof(int *(*y)[3])");
  assert(16, sizeof(hoge), "sizeof(hoge)");
}

void f50_large_number_literal() {
  long x = 2147483647; // 2 ^ 31 - 1
  long y = 2147483648; // 2 ^ 31

  assert(y, x + 1, "y == x + 1");
}

int main() {
  test_count = 0;
  ok_count = 0;

  assert(0 , 0, "0");
  assert(42, 42, "42");
  assert(21, 5+20-4, "5+20-4");
  assert(41, 12 + 34 - 5 , "12 + 34 - 5 ");
  assert(47, 5+6*7, "5+6*7");
  assert(15, 5 * (9- 6), "5 * (9- 6)");
  assert(4 , ( 3 + 5) / 2, "( 3 + 5) / 2");
  assert(60, (1 + 2) * 3 + 4 + (5 + 6 * 7), "(1 + 2) * 3 + 4 + (5 + 6 * 7)");
  assert(5 , -1 + 2 * 3, "-1 + 2 * 3");
  assert(5 , -1 + +2 * 3, "-1 + +2 * 3");
  assert(12, -(-1 + -2) * 4, "-(-1 + -2) * 4");
  assert(0 , 0==1, "0==1");
  assert(1 , 42==42, "42==42");
  assert(1 , 0!=1, "0!=1");
  assert(0 , 42!=42, "42!=42;");
  assert(1 , 0<1, "0<1");
  assert(0 , 1<1, "1<1");
  assert(0 , 2<1, "2<1");
  assert(1 , 0<=1, "0<=1");
  assert(1 , 1<=1, "1<=1");
  assert(0 , 2<=1, "2<=1");
  assert(1 , 1>0, "1>0");
  assert(0 , 1>1, "1>1");
  assert(0 , 1>2, "1>2");
  assert(1 , 1>=0, "1>=0");
  assert(1 , 1>=1, "1>=1");
  assert(0 , 1>=2, "1>=2");
  {int a; a = 10; assert(10, a, "int a; a = 10");}
  {int a; int b; a=10;b=a; assert(11, b + 1, "int a; int b; a=10;b=a; b + 1");}
  {int a; int b; a=b=10; a+b; assert(20, a + b, "{int a; int b; a=b=10; a+b}");}
  {int a; int b; a = 1 + 2; b = 3 * 4; a + b; assert(15, a + b, "int a; int b; a = 1 + 2; b = 3 * 4; a + b");}
  {int foo; int bar; foo = 1 + 2; bar = 3 * 4; assert(15, foo + bar, "int foo; int bar; foo = 1 + 2; bar = 3 * 4; foo + bar");}
  {int foo; int boo; int a; a=foo=1; boo = a + foo; boo == 2; assert(1, boo == 2, "int foo; int boo; int a; a=foo=1; boo = a + foo; boo == 2;");}
  {int b; int boo; b=boo =1; b + boo + 2; assert(4, b + boo + 2, "int b; int boo; b=boo =1; b + boo + 2");}
  assert(10, f1_while(), "f1_while()");
  assert(30, f2_while(), "f2_while()");
  assert(11, f3_if(), "f3_if()");
  assert(12, f4_if(), "f4_if()");
  assert(13, f5_if(), "f5_if()");
  assert(12, f6_if(), "f6_if()");
  assert(13, f7_if(), "f7_if()");
  assert(11, f8_if(), "f8_if()");
  assert(4, f9_while_if(), "f9_while_if()");
  assert(5, f10_while_if(), "f10_while_if()");
  assert(11, f11_return(), "f11_return()");
  assert(45, f12_for(), "f12_for()");
  assert(45, f13_for(), "f13_for()");
  assert(45, f14_for(), "f14_for()");

  assert(2, foo_return2(), "foo_return2()");
  assert(4, 2 + foo_return2(), "2 + foo_return2()");
  assert(5, foo_with_args_add(2, 3), "foo_with_args_add(2, 3)");
  assert(10, f15_call_func(), "f15_call_func()");
  assert(21, foo_with_args_add6(1, 2, 3, 4, 5, 6), "foo_with_args_add6(1, 2, 3, 4, 5, 6)");
  assert(120, fact(5), "fact(5)");
  assert(55, fib(10), "fib(10)");
  assert(1, f16_for_while_if_func_arg(2, 3), "f16_for_while_if_func_arg(2, 3)");

  {int foo; foo = 3; assert(3, *&foo, "int foo; foo = 3; *&foo;");}
  {int foo; int *boo; foo = 3; boo = &foo; assert(3, *boo, "int foo; int *boo; foo = 3; boo = &foo; *boo");}
  {int a; int b;int c;int *d; a = 4; b = 5; c = 6; d = &a + 1; assert(5, *d, "{int a; int b;int c;int *d; a = 4; b = 5; c = 6; d = &a + 1; *d; }");}
  {int a; int b; int c; int *d; a = 4; b = 5; c = 6; d = &c - 1; assert(5, *d, "{int a; int b; int c; int *d; a = 4; b = 5; c = 6; d = &c - 1; }");}
  {int a; int b; int c; a = 4; b = 5; c = 6; *(&c - 1) = 12; assert(12, b, "{int a; int b; int c; a = 4; b = 5; c = 6; *(&c - 1) = 12; }");}
  {int x; x=3; *&x; assert(3, *&x, "{int x; x=3; *&x;}");}
  {int x; int *y; int **z;x=3; y=&x; z=&y; assert(3, **z, "{int x; int *y; int **z;x=3; y=&x; z=&y; }");}
  {int x; int y; x=3; y=5; assert(5, *(&x+1), "{int x; int y; x=3; y=5; }");}
  {int x; int y; x=3; y=5; assert(3, *(&y-1), "{int x; int y; x=3; y=5; }");}
  {int x; int *y; x=3; y=&x; *y=5; assert(5, x, "{int x; int *y; x=3; y=&x; *y=5; }");}
  {int x; int y; x=3; y=5; *(&x+1)=7; assert(7, y, "{int x; int y; x=3; y=5; *(&x+1)=7; }");}
  {int x; int y; x=3; y=5; *(&y-1)=7; assert(7, x, "{int x; int y; x=3; y=5; *(&y-1)=7; }");}

  assert(23, f17_pointer(), "f17_pointer()");

  {int *p; alloc_3num_ary_8_byte_cell(&p); assert(3, *(p + 1), "int *p; alloc_3num_ary_8_byte_cell(&p); *(p + 1);"); }
  {int *p; alloc_3num_ary_8_byte_cell(&p); assert(4, *(2 + p), "int *p; alloc_3num_ary_8_byte_cell(&p); return *(2 + p)"); }
  {int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = p + 3; assert(3, q - p, "int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = q + 3; q - p;"); }
  {int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = p + 3; assert(4, *(q - 1), "int *p; int *q; alloc_3num_ary_8_byte_cell(&p); q = q + 3; *(q - 1);"); }

  assert(8, sizeof(1), "sizeof(1)");
  { int x;
    int *y;
    int **z;
    assert(4, sizeof(x), "sizeof(x)");
    assert(8, sizeof(&x), "sizeof(&x)");
    assert(8, sizeof(y), "sizeof(y)");
    assert(8, sizeof(1 + 2), "sizeof(1 + 2)");
    assert(8, sizeof z, "sizeof z");
    assert(8, sizeof(sizeof(0)), "sizeof(sizeof(0))");
    assert(8, sizeof sizeof &x, "sizeof sizeof &x");
  }

  assert(3, f18_ary(), "f18_ary()");
  assert(6, f19_ary(), "f19_ary()");
  assert(6, f20_ary(), "f20_ary()");

  {int x[2][3]; int *y; y = x; *y=0;     assert(0, **x, "int x[2][3]; int *y; y = x; *y=0;*y=0; ");}
  {int x[2][3]; int *y; y = x; *(y+1)=1; assert(1, *(*x+1), "int x[2][3]; int *y; y = x; *(y+1)=1; *(y+1)=1;");}
  {int x[2][3]; int *y; y = x; *(y+2)=2; assert(2, *(*x+2), "int x[2][3]; int *y; y = x; *(y+2)=2; *(y+2)=2;");}
  {int x[2][3]; int *y; y = x; *(y+3)=3; assert(3, **(x+1), "int x[2][3]; int *y; y = x; *(y+3)=3; *(y+3)=3;");}
  {int x[2][3]; int *y; y = x; *(y+4)=4; assert(4, *(*(x+1)+1), "int x[2][3]; int *y; y = x; *(y+4)=4; *(y+4)=4;");}
  {int x[2][3]; int *y; y = x; *(y+5)=5; assert(5, *(*(x+1)+2), "int x[2][3]; int *y; y = x; *(y+5)=5; *(y+5)=5;");}
  {int x[2][3]; int *y; y = x; *(y+6)=6; assert(6, **(x+2), "int x[2][3]; int *y; y = x; *(y+6)=6; *(y+6)=6;");}

  assert(21, f21_ary(), "f21_ary()");
  assert(0, f22_x, "f22_x");
  {f23_x_test(5); assert(5, f23_x, "f23_x_test(5); f23_x;");}
  assert(6, f24_helper(), "f24_helper()");
  assert(12, f25_helper(), "f25_helper()");
  {char x; assert(1, sizeof(x), "char x; sizeof(x)");}
  {char x[10]; assert(10, sizeof(x), "char x[10]; sizeof(x)");}
  assert(5, f26_char(), "f26_char()");
  assert(5, f27_helper(), "f27_helper()");
  assert(1, f28_sub_char(7, 3, 3), "f28_sub_char(7, 3, 3);");
  assert(97, "abc"[0], "\"abc\"[0]");
  assert(98, "abc"[1], "\"abc\"[1]");
  assert(99, "abc"[2], "\"abc\"[2]");
  assert(0, "abc"[3], "\"abc\"[3]");
  assert(10, "\n"[0], "\"\\n\"[0]");
  assert(9, "\t"[0], "\"\\t\"[0]");
  assert(34, "\""[0], "\"\\\"\"[0]");
  assert(92, "\\"[0], "\"\\\\\"[0]");

  assert(0, 4 % 2, "4 % 2");
  assert(1, 4 % 3, "4 % 3");
  assert(2, 5 % 3, "5 % 3");

  // this line is single line comment
  /*
    this
    area
    is
    block
    comment
    */
  assert(3, 1 + 2, "1 + 2");
  assert(56, f29_initialize_local_var(), "f29_initialize_local_var()");
  assert(15, f30_struct_member(), "f30_struct_member()");

  // 型のサイズだけでいうと5バイトだが、int(4バイト)とcharが混在しているため、
  // int側のアラインメントに合わされて構造体
  struct {
    int x;
    char y;
  } s1;
  assert(8, sizeof(s1), "sizeof(s1)");

  struct {
    char x;
    int y;
  } s2;
  assert(8, sizeof(s2), "sizeof(s2)");

  struct {
    char x;
    char y;
  } s3;
  assert(2, sizeof(s3), "sizeof(s3)");

  struct {
    int x;
    int y;
  } s4;
  assert(8, sizeof(s4), "sizeof(s4)");

  assert(1, f31_local_variable_alignment(), "f31_local_variable_alignment()");
  assert(7, f32_local_variable_alignment(), "f32_local_variable_alignment()");
  assert(36, f33_use_struct_tag(), "f33_use_struct_tag()");
  assert(10, f34_arrow_operator(), "f34_arrow_operator()");
  assert(60, f35_typedef_stmt(), "f35_typedef_stmt()");
  assert(3, f36_global_typedef(), "f36_global_typedef()");
  assert(2, f37_fix_char_mov(), "f37_fix_char_mov()");

  long f38_val;
  assert(8, sizeof(f38_val), "sizeof(f38_val)");
  assert(16, f39_struct_included_long(), "f39_struct_included_long()");

  short f40_val;
  assert(2, sizeof(f40_val), "sizeof(f40_val)");
  assert(34, f41_long_short_int_char_args(10, 9, 8, 7), "f41_long_short_int_char_args(10, 9, 8, 7)");

  assert(21, f42_use_all_argument_register_short(1, 2, 3, 4, 5, 6), "use_all_argument_register_short(1, 2, 3, 4, 5, 6)");
  assert(21, f42_use_all_argument_register_int(1, 2, 3, 4, 5, 6), "use_all_argument_register_short(1, 2, 3, 4, 5, 6)");
  assert(21, f42_use_all_argument_register_char(1, 2, 3, 4, 5, 6), "use_all_argument_register_short(1, 2, 3, 4, 5, 6)");
  f43_nested_decl();
  assert(3, f44_hogehoge(1, 2), "f44_hogehoge(1, 2)");

  f45_call_void_func();
  f46_bool_test();
  f47_long_long();
  f48_complex_decl();
  f49_sizeof_type_argument();
  f50_large_number_literal();

  //------------------------------------------------------------------------
  // ここより上にテストを書く
  printf("total: %d tests, %d ok\n", test_count, ok_count);
  if (test_count == ok_count) {
    return 0;
  } else {
    return 1;
  }
}

